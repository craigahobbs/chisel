# Licensed under the MIT License
# https://github.com/craigahobbs/chisel/blob/main/LICENSE

include <unittest.bare>
include <unittestMock.bare>

include '../chiselDoc.bare'


async function testChiselDoc_index():
    # Setup mocks
    unittestMockAll({ \
        'systemFetch': { \
            'doc_index': jsonStringify({ \
                'title': 'localhost:8080', \
                'groups': { \
                    '2 Group': ['3action'], \
                    '1_Group': ['2+action', '1_action'] \
                } \
            }) \
        } \
    })

    # Render the index
    chiselDoc()

    # Reset mocks
    unittestDeepEqual(unittestMockEnd(), [ \
        ['systemFetch', ['doc_index']], \
        ['documentSetTitle', ['localhost:8080']], \
        ['markdownPrint', ['# localhost:8080']], \
        ['markdownPrint', ['', '## 1\\_Group']], \
        ['markdownPrint', ['', "[1\\_action](#var.vName='1_action'&_top)"]], \
        ['markdownPrint', ['', "[2\\+action](#var.vName='2%2Baction'&_top)"]], \
        ['markdownPrint', ['', '## 2 Group']], \
        ['markdownPrint', ['', "[3action](#var.vName='3action'&_top)"]] \
    ])
endfunction
unittestRunTest('testChiselDoc_index')


async function testChiselDoc_index_urlError():
    # Setup mocks
    unittestMockAll()

    # Render the index
    chiselDoc()

    # Reset mocks
    unittestDeepEqual(unittestMockEnd(), [ \
        ['systemFetch', ['doc_index']], \
        ['markdownPrint', ['**Error:** Failed to fetch chisel index API "doc_index"']] \
    ])
endfunction
unittestRunTest('testChiselDoc_index_urlError')


async function testChiselDoc_request():
    # Setup mocks
    unittestMockAll({ \
        'systemFetch': { \
            'doc_request?name=test%2Brequest': jsonStringify({ \
                'doc': 'The test request', \
                'urls': [{'path': '/url1'}, {'method': 'GET', 'path': '/url2'}] \
            }) \
        } \
    })

    # Render the index
    systemGlobalSet('vName', 'test+request')
    chiselDoc()
    systemGlobalSet('vName', null)

    # Reset mocks
    unittestDeepEqual(unittestMockEnd(), [ \
        ['systemFetch', ['doc_request?name=test%2Brequest']], \
        ['documentSetTitle', ['test+request']], \
        ['markdownPrint', ['[Index](#var=)']], \
        ['markdownPrint', ['','# test\\+request']], \
        ['markdownPrint', ['','The test request']], \
        ['markdownPrint', ['','**Note:** The request is exposed at the following URLs:']], \
        ['markdownPrint', ['','&nbsp;&nbsp;[ /url1](/url1)']], \
        ['markdownPrint', ['','&nbsp;&nbsp;[GET /url2](/url2)']] \
    ])
endfunction
unittestRunTest('testChiselDoc_request')


async function testChiselDoc_request_noDocNoURLs():
    # Setup mocks
    unittestMockAll({ \
        'systemFetch': { \
            'doc_request?name=test%2Brequest': jsonStringify({}) \
        } \
    })

    # Render the index
    systemGlobalSet('vName', 'test+request')
    chiselDoc()
    systemGlobalSet('vName', null)

    # Reset mocks
    unittestDeepEqual(unittestMockEnd(), [ \
        ['systemFetch', ['doc_request?name=test%2Brequest']], \
        ['documentSetTitle', ['test+request']], \
        ['markdownPrint', ['[Index](#var=)']], \
        ['markdownPrint', ['','# test\\+request']] \
    ])
endfunction
unittestRunTest('testChiselDoc_request_noDocNoURLs')


async function testChiselDoc_request_noDocEmptyURLs():
    # Setup mocks
    unittestMockAll({ \
        'systemFetch': { \
            'doc_request?name=test%2Brequest': jsonStringify({'urls': []}) \
        } \
    })

    # Render the index
    systemGlobalSet('vName', 'test+request')
    chiselDoc()
    systemGlobalSet('vName', null)

    # Reset mocks
    unittestDeepEqual(unittestMockEnd(), [ \
        ['systemFetch', ['doc_request?name=test%2Brequest']], \
        ['documentSetTitle', ['test+request']], \
        ['markdownPrint', ['[Index](#var=)']], \
        ['markdownPrint', ['','# test\\+request']] \
    ])
endfunction
unittestRunTest('testChiselDoc_request_noDocEmptyURLs')


async function testChiselDoc_request_action():
    # Setup mocks
    unittestMockAll({ \
        'systemFetch': { \
            'doc_request?name=testAction': jsonStringify({ \
                'types': { \
                    'testAction': { \
                        'action': { \
                            'name': 'testAction' \
                        } \
                    } \
                } \
            }) \
        } \
    })

    # Render the index
    systemGlobalSet('vName', 'testAction')
    chiselDoc()
    systemGlobalSet('vName', null)

    # Reset mocks
    unittestDeepEqual(unittestMockEnd(), [ \
        ['systemFetch', ['doc_request?name=testAction']], \
        ['documentSetTitle', ['testAction']], \
        ['markdownPrint', ['[Index](#var=)']], \
        ['markdownPrint', [ \
             [ \
                "# action testAction", \
                "", \
                "## Error Codes", \
                "", \
                "If an application error occurs, the response is of the form:", \
                "", \
                "```json", \
                "{", \
                "    \"error\": \"<error>\",", \
                "    \"message\": \"<message>\"", \
                "}", \
                "```", \
                "", \
                "`message` is optional. `error` is one of the following values:", \
                "", \
                "| Value           |", \
                "|-----------------|", \
                "| UnexpectedError |" \
            ] \
        ]] \
    ])
endfunction
unittestRunTest('testChiselDoc_request_action')


async function testChiselDoc_request_urlError():
    # Setup mocks
    unittestMockAll()

    # Render the index
    systemGlobalSet('vName', 'testAction')
    chiselDoc()
    systemGlobalSet('vName', null)

    # Reset mocks
    unittestDeepEqual(unittestMockEnd(), [ \
        ['systemFetch', ['doc_request?name=testAction']], \
        ['markdownPrint', ['**Error:** Failed to fetch chisel request API "doc_request?name=testAction"']] \
    ])
endfunction
unittestRunTest('testChiselDoc_request_urlError')
